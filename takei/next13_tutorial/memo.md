## 基本

### CSR,SSR,SG,ISRについて

#### 前提
- CSR,SSR,SG,ISR全ての手法でデータを扱うことができる

#### 内容

- コベツバでは主にISR,CSRを採用する
  - SSGは、キャッシュ期限がいつ切れるか分からない（設定したら別だけど）ことがあるため、ISRを採用
  - CSRは、秒/分単位で更新のかかるデータを扱うため、採用する

- ISR,CSRどちらを利用しますか？
  - 判断方法は、「このデータ、どの頻度で変わりますか？」
    - ユーザー/セッション関連のデータなら、秒/分単位。キャッシュ消ししまくるのは良くない。CSRで取る
    - ユーザー/セッション関連じゃないなら、運営者/CRONの何かのアクションない限り変わらない＝一日から数ヶ月単位。ISRで生成する/更新していく。

また、ISRとCSRを合体[^1]出来るので、ISRでユーザーデータ以外の整理をして、CSRでユーザーのデータで生成されるUIのみを作る、ということが綺麗です。
[^1]:合体というのがISRのコンポーネントとCSRのコンポーネントということ

appルーターでは、ISR/SSG/SSR/CSRという言葉をほぼ使っていない。
理由として、
- SSGがデフォルト
- パラメータ/revalidation関数ですぐISRに移動出来る
- SSRも同じくパラメーターで設定することになる
- useSWRなどを使ったらCSRと認識される
というふうに設定ができるため、next公式ドキュメントでもISR/SSG/SSR/CSRという言葉をいっていない。

そのため、
- キャッシュしない（＝SSR）
- キャッシュ期間を短くする/Revalidate入れる（＝ISR）
- ブラウザーで取る（＝CSR）

と認識するのが良い

## 作成していて気づいたこと

- layout.tsxにhtmlタグやbodyタグの記載をする
- [〇〇]のpage.tsxにはパラメータを受け取るため、paramsが必ず入っているだろう

- 基本SG SSRで作成される。コベツバでは、変更のない静的htmlがほぼないからSSR,CSRになるだろう

- Server Componentで、useStateやuseEffectを利用できない
  - SSRでは、サーバーが静的htmlデータを返しているのみなので、状態をクライアントがもっていないため
- Client Component として扱うためには、`use client` を宣言したファイルでラップする

- Next.js でデータフェッチングを行うにはサーバーサイドで行うことが一般的？
  - コベツバもasync/awaitを利用して取得する、？(Fetch API？)

- error.tsx は必ず Client Component として扱われます。なぜ？
- 依存関係のない複数の API を呼び出す場合は処理が並列になるように Promise.all を使うことが推奨されます。


### reactとの比較(楽になったな‐というところ)
- react routerでやっていたことがフォルダ構造で出来ること
- reactだとローディング中のフラグだったりを作って、制御していた
- データがあるかないかでの、読み込みページの記載がなくなった(はず)